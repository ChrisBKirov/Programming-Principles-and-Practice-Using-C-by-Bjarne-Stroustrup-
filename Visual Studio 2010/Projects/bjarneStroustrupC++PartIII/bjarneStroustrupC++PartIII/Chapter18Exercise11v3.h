/*
	TITLE		    Skip List	            Chapter18Exercise11v3.h
	"Bjarne Stroustrup "C++ Programming: Principles and Practice.""
	COMMENT
		Objcective: Research and implement the data structure:
					Skip List. 
		       
		     Input: -
			Output: -
			Author: Chris B. Kirov
			  Date: 27.12.2015
*/
#ifndef CHAPTER18EXERCISE11V3_H
#define CHAPTER18EXERCISE11V3_H 

//====================================================================================================================
class Skip_list {
public:
	Skip_list ();
	~Skip_list ();

	// non - modifying members 
	void print () const;
	std::string* find (int searchKey) const;

	// modifying members
	void insert (int searchKey, std::string newValue);
	void erase (int searchKey); 
	
private:

	// Node structure
	struct Skip_Node {
		// node data members
		int key;
		std::string value;

		// pointers to successor nodes
		std::vector<Skip_Node*> forward;

		// constructor
		Skip_Node (int k, const std::string& v, int level)
			:  key(k), value(v)
		{
			for (int i = 0; i < level; ++i) forward.emplace_back(nullptr);
		} 
	};

	// implicitly used members
	int randomLevel () const; 

	static int nodeLevel (const std::vector<Skip_Node*>& v);

	static Skip_Node* makeNode (int key, std::string val, int level);

	std::vector<Skip_list::Skip_Node*> Skip_list::predecessors (int searchKey) const;

	Skip_Node* lower_bound (int searchKey) const ;

	// Data members

	// pointer to first node
	Skip_Node* head;

	// pointer to last node
	Skip_Node* NIL;

	/*
		Data Member: probability
		It determines the fraction,
		p, or (probability) of the nodes
		with level i that also have 
		level i + 1 pointers.
		In our case p = 0.5 (or 50%).
	*/
	float probability;

	/*
		Data Member: maxLevel
		It detemines the maximum level
		a node can have based on the 
		upper bound of the total elements
		of the list, N.

		maxLevel = L(N), where
		L(N) = log1/p(N).

		The maxLevel = 16 is determined 
		by the fact that the probablilty
		of 0.5 is appropriate for skip 
		lists with elements up to 2^16.
	*/
	int maxLevel;
};

//====================================================================================================================
//Implementations
 
// Class Skip_list member implementations
// constructor
Skip_list::Skip_list()
	: probability(0.5), maxLevel(16)
{
	 // Initialize the head of the skip list

	 // smallest possible key
     int headKey = std::numeric_limits<int>::min();
	 head = new Skip_Node(headKey, "head", maxLevel);

	 // Initialize the last element of the list

	 // largest possible key
	 int nilKey = std::numeric_limits<int>::max();
	 NIL = new Skip_Node(nilKey, "NIL", maxLevel);

	 // Connect start to end
	 // connect all the levels/forward pointers of the header to NIL
	 for (size_t i = 0; i < head->forward.size(); ++i) {
		 head->forward[i] = NIL;
	 }
}

// destructor
Skip_list::~Skip_list () {
	Skip_Node *node = head;
	// delete skip list front to back
	while (node) {
		// advance to next node
		Skip_Node *succ  = node->forward[0];

		// delete current node
		delete node;

		// reassign node to successor 
		node = succ;
	}
	delete node;
}

// Helper functions
/*
	Function: randomLevel()
	Use: implicit in class Skip_list
	It generates node levels in the range
	[1, maxLevel). 

	It uses rand() scaled by its maximum 
	value: RAND_MAX, so that the randomly 
	generated numbers are within [0,1).

	Based on the above the returnig values
	of the function are within [1,16).

	Tested for 5000 elements, with results:
	level 1: 2561  level 6: 70   level 11: 4
	level 2: 1225  level 7: 44   level 12: 1
 	level 3: 607   level 8: 17   level 13: 0
	level 4: 312   level 9: 9    level 14: 0
	level 5: 147   level 10: 3   level 15: 0

*/
int Skip_list::randomLevel () const {
	static bool seed_initialized = false;

	if (!seed_initialized) {

		srand ((unsigned) time(NULL));
		seed_initialized = true;
	}
	// first level corresponds to index 0 in the vector ?!
	int l = 1;

	while (((double)std::rand() / RAND_MAX) < probability && 
		   l < maxLevel) {

		++l;
	}
	return l;
}

/*
	Function: nodeLevel()
	Use: Implicitly in most of the member functions.

	Observing the distribution of the node's levels,
	generated by the randomLevel() function, one notices
	that most of the nodes(97%) have levels: from 1 to 5,
	i.e. the distribution is with positive skewness.

	That is why instead of traversing the nodes every
	time from MaxLevel = 16 to 1-st level
	(as suggested by the papers), in every member 
	function: find() (insert(), delete()), I introduce
	this function that calculates the "current" level
	of the node by counting from bottom to top, which
	will be shorter, with (16 - 5 = 11 iterations + 11 comparisons) 
	in the most (97%) of the cases.

	It returns the number of non-null pointers
	corresponding to the level of the current node.
	(the node that contains the checked vector of 
	forward pointers)

	If list empty returns 1.
*/
int Skip_list::nodeLevel (const std::vector<Skip_Node*>& v) {
	int currentLevel = 1;
	// last element's key is the largest
	int nilKey = std::numeric_limits<int>::max();

	// this forward vector belongs to NIL node, return 1
	if (v[0]->key == nilKey) {

		return currentLevel;
	}

	for (size_t i = 0; i < v.size(); ++i) {

		if (v[i] != nullptr && v[i]->key != nilKey) {

			++currentLevel;
		} else { 

			break;
		}
	}
	return currentLevel;
}

/*
	Function: makeNode ()
	Use: Implicitly in member function insert().

	It wraps the node constructor which creates
	a node on the heap. 
	
	It returns a pointer 
	to a dynamically allocated node.
*/
Skip_list::Skip_Node* Skip_list::makeNode (int key, std::string val, int level) {
	return new Skip_Node(key, val, level);
}

/*
	Function: :predecessors();
	Use: Implicitly used in the member functions.

	It returns a vector of pointers to nodes.

	result[i] holds the last node of level i+1
	for which result->key < seachKey is true.

	update holds all the forward pointers 
	pointing (and above) the last node for which
	node->key < searchKey.
*/
std::vector<Skip_list::Skip_Node*> Skip_list::predecessors(int searchKey) const {
	// initialize vector of null pointers of size: nodeLevel
	std::vector<Skip_Node*> update(head->forward);
	Skip_Node* x = head;

	for (unsigned int i = nodeLevel(head->forward); i-- > 0;) {
		while (x->forward[i]->key < searchKey) {
			x = x->forward[i];
		}
		update[i] = x;
	}
    return update;
}

/*
	Function: lower_bound()
	Use: Implicitly in the class members.

	It returns the first node for which
	node->key < searchKey is false.
*/
Skip_list::Skip_Node* Skip_list::lower_bound(int searchKey) const {
	Skip_Node* x = head;

	for (unsigned int i = nodeLevel(head->forward); i-- > 0;) {
        while ( x->forward[i]->key < searchKey) {
            x = x->forward[i];
        }
    }
    return x->forward[0];
}

// Non-modifying member functions
/*
	Function: print()
	Use: skip_list_obj.print();

	It prints the key, value, level
	of each node of the skiped list.

	Prints two nodes per line.
*/
void Skip_list::print () const {
	Skip_Node* list = head;
	int lineLenght = 1;

	std::cout <<"{";

	while (list->forward[0] != nullptr) {
		std::cout <<"value: "<< list->forward[0]->value
			      <<", key: "<< list->forward[0]->key
				  <<", level: "<< nodeLevel(list->forward); 

		list = list->forward[0];

		if (list->forward[0] != nullptr) std::cout <<" : ";

		if (++lineLenght % 2 == 0) std::cout <<"\n";
	}
	std::cout <<"}\n";
}

/*
	Function: find()
	Use: std::string* found_value = skip_list_obj.find(searchKey);

	It searches the skip list and returns the element's value
	corresponding to the searchKey; otherwise it returns failure,
	in the form of null pointer.
*/
std::string* Skip_list::find(int searchKey) const {
	Skip_Node* x = lower_bound(searchKey);

	if (x) { 

		if (x->key == searchKey && x != NIL) {

			return &(x->value);
		}
	}
	return nullptr; 
} 

// Modifying member functions

/*
	Function: insert();
	Use: void insert(searchKey, newValue);

	It searches the skip list for elements
	with that seachKey, if there is an element
	with that key its value is reassigned to the 
	newValue, otherwise it creates and splices
	a new node, of random level.
*/
void Skip_list::insert(int searchKey, std::string newValue) {
	// Reassign if node exists 
	// predecessors returns all the forward pointers pointing and above the last node for which node->key < searchKey
	std::vector<Skip_list::Skip_Node*> update = predecessors(searchKey);
	
	// if we access update's next, it should be the node with existing key
	Skip_Node* x = nullptr;
	x = update[0]->forward[0]; 
 
	if (x->key == searchKey && x != NIL) {
		x->value = newValue;
		return;
	}
	
	// Create new node
	int newNodeLevel = randomLevel();
	x = makeNode(searchKey, newValue, newNodeLevel); 

	// connect pointers of predecessors and new node to successors
	for (int i = 0; i < newNodeLevel; ++i) {
		 
		x->forward[i] = update[i]->forward[i];
		update[i]->forward[i] = x;
	}
}

/*
	Function: delete_node()
	Use: skip_list_obj.erase(searchKey)

	It deletes the element containing 
	searchKey, it it exists.
*/
void Skip_list::erase (int searchKey) {
	// predecessors returns all the forward pointers pointing and above the last node for which node->key < searchKey
	std::vector<Skip_Node*> update(predecessors(searchKey));

	// if we access update's next, it should be the node with existing key
	Skip_Node* x = nullptr;
	x = update[0]->forward[0];

	// node does not exist
	if (!x || x->key != searchKey) return;

	// update x's predecessors forward pointers to point to x's successors and delete node 
	for (size_t i = 0; i < update.size(); ++i) {

		if (update[i]->forward[i] != x) {
			// do not update forward pointers higher than x's level
			break;
		}
		update[i]->forward[i] = x->forward[i];
	}
	delete x;		 	 
}

#endif