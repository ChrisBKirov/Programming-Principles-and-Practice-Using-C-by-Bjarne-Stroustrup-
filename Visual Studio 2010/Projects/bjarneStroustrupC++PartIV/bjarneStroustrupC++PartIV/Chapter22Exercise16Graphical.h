/*
	TITLE		   Programming Languages Connection			Chapter22Exercise16Graphical.h
	COMMENT
		Objective: Modify the program from the previous exercise so that it reads a file of
				   (name,year,(ancestors)) tuples, such as (Fortran,19S6,()), (Algol,1960,(Fortran))
				   , and (C++,198S,(C,Simula)), and graphs them on a timeline with arrows from 
				   ancestors to descendants. Use this program to draw improved versions of the
				   diagrams in §22.2.2 and §22.2.7. 
			Input: -
		   Output: -
		   Author: Chris B. Kirov
			 Date: 10.04.2017
*/
#ifndef Chapter22Exercise16Graphical_h
#define Chapter22Exercise16Graphical_h

#define PI 3.14159265359

// class Arrow
class Arrow: public Lines
{
public:
	Arrow(Point p1, Point p2, int arr);

private:
	Point rotate_point(Point pivot, float angle, Point p); 
	int arrowSize;
};

//-------------------------------------------------------------------------------------------------------

Arrow::Arrow(Point p1, Point p2, int arr)
	: arrowSize(arr)
{
	Shape::add(p1);
	Shape::add(p2);
	// The arrow head is generated by rotating a point on the line around the second(end) point
	// of the line in at the same angle in both directions, then using these points to generate lines
	// norm of the vector p1p2
	int x = abs(p2.x - p1.x);
	int y = abs(p2.y - p1.y);
	double norm = sqrt(double(x*x + y*y));
	// unit vector along the vector p1p2; 
	// multiplied be the wanted size of the arrow so that the division by the norm is > 1
	Point unitVector(double(x*arrowSize) / double(norm), double(y*arrowSize)/double(norm));
	// rotate a point on the line located just before p2, 30 degrees in both directions around p2
	Point arrow1;
	Point arrow2;
	// cover all the possible slopes
	if (double(p2.y - p1.y) >= 0 && double(p2.x - p1.x) >= 0)
	{
		arrow1 = rotate_point(p2, 30, Point(p2.x - unitVector.x, p2.y - unitVector.y));
		arrow2 = rotate_point(p2, 330, Point(p2.x - unitVector.x, p2.y - unitVector.y));
	}
	else if (double(p2.y - p1.y) >= 0 && double(p2.x - p1.x) < 0)
	{
		arrow1 = rotate_point(p2, 30, Point(p2.x + unitVector.x, p2.y - unitVector.y));
		arrow2 = rotate_point(p2, 330, Point(p2.x + unitVector.x, p2.y - unitVector.y));
	}
	else if (double(p2.y - p1.y) < 0 && double(p2.x - p1.x) < 0)
	{
		arrow1 = rotate_point(p2, 30, Point(p2.x + unitVector.x, p2.y + unitVector.y));
		arrow2 = rotate_point(p2, 330, Point(p2.x + unitVector.x, p2.y + unitVector.y));
	}
	else if (double(p2.y - p1.y) < 0 && double(p2.x - p1.x) >= 0)
	{
		arrow1 = rotate_point(p2, 30, Point(p2.x - unitVector.x, p2.y + unitVector.y));
		arrow2 = rotate_point(p2, 330, Point(p2.x - unitVector.x, p2.y + unitVector.y));
	}
	// generate first part of the arrow
	Shape::add(p2);
	Shape::add(arrow1);
	// generate second part of the arrow
	Shape::add(p2); 
	Shape::add(arrow2); 
}

//-------------------------------------------------------------------------------------------------------

Point Arrow::rotate_point(Point pivot, float angle, Point p)
{
	 float angleRad = angle * PI / 180.;
     return Point(cos(angleRad ) * (p.x - pivot.x) - sin(angleRad ) * (p.y - pivot.y) + pivot.x,
                  sin(angleRad ) * (p.x - pivot.x) + cos(angleRad ) * (p.y - pivot.y) + pivot.y);
}

//-------------------------------------------------------------------------------------------------------

/* Draws an unweighted & directed Graph */ 
class PlotGraph: Window
{
public:
	PlotGraph(std::string& file_name) 
		: Window(Point(200,200), 700, 700, "Chapter 22 Exercise 16"),
		timeline(nullptr),
		quit_button(Point(x_max() - 80, 10), 70, 20, "Quit", cb_quit)
	{ 
		read_file(file_name);

		// control lines
		std::cout <<"Nodes:" << g.get_node_number() <<", Edges: "<< g.get_total_edge_number();
		std::cout <<"\nGraph density: " << g.get_graph_density() <<'\n';
		g.sort_graph();
		std::cout <<"\n\n";
		g.print_nodes();

		make_graph();

		for (size_t i = 0; i < nodes_years.size(); ++i) attach(*nodes_years[i]);
		for (size_t i = 0; i < edges.size(); ++i) attach(*edges[i]);
		for (size_t i = 0; i < nodes_text.size(); ++i) attach(*nodes_text[i]);

		attach(*timeline);
		attach(quit_button);
	}

private:
	// controls
	Graph_lib::Button quit_button;

	// callbacks
	static void cb_quit (Address, Address pw) { reference_to<PlotGraph>(pw).quit_pressed(); }

	// actions
	void quit_pressed() { hide(); }

	//helpers
	void read_file(const std::string& file_name);
	void make_graph();

	// data
	// abstract representation of data
	Graph g;

	// graphical representation of data
	std::vector<Point*> nodes_coordinates;
	std::vector<Graph_lib::Text*> nodes_text;
	std::vector<Graph_lib::Text*> nodes_years;
	std::vector<Arrow*> edges;	// include class Arrow from Chapter13Exercise3
	Graph_lib::Axis* timeline;
};

//-------------------------------------------------------------------------------------------------------

void PlotGraph::read_file(const std::string& file_name)
{
	std::ifstream ifs(file_name.c_str());
	if (!ifs) std::cerr <<"Can't open input file!\n";

	std::string line;
	while (getline(ifs, line))
	{
		std::cout << line <<'\n';
		if (line.size() < 5) // Avoid Assert  char + 1 < 256 failure. Due to EOF?
		{
			break;
		}

		std::stringstream ss(line);

		Node n;
		ss >> n;

		g.add_node(n);
	}	
}

//-------------------------------------------------------------------------------------------------------

void PlotGraph::make_graph()
{
	const int xoffset = 50;
	const int yoffset = 50;
	const int axis_length = 700 - 2 * yoffset;

	// max_year - min_year = points_range; 
	int points_range = g.nodes[g.nodes.size() - 1].get_year() - g.nodes[0].get_year();
	const int y_scale = axis_length / (float) points_range;  // one year in pixels = axis_length / points_range  
	int x_scale = 5; // avoid name overlapping 

	// on every years from min to max: point_range 
	const int notches = points_range; 

	Point origin(xoffset, yoffset + axis_length);

	// axis representing timeline with few years marked for reference
	timeline = new Graph_lib::Axis(Graph_lib::Axis::Orientation::y, origin, axis_length, notches, "Time[Years]");
	timeline->label.move(-38,-20);

	// assign time labels on the axis
	int origin_year = g.nodes[0].get_year();
	for (size_t i = 0; i < g.get_node_number(); ++i)
	{
		std::stringstream ss;
		int current_year = g.nodes[i].get_year();
		ss << current_year;

		Point p(origin.x - xoffset, origin.y - axis_length + (current_year - origin_year) * y_scale);

		nodes_years.emplace_back(new Graph_lib::Text(p, ss.str()));
	}

	srand(time(NULL)); // generate x coordinate and edge colour

	// generate points associated with each node of the graph
	for (size_t i = 0; i < g.get_node_number(); ++i)
	{
		int current_year = g.nodes[i].get_year();

		x_scale = rand() % 550 + 5;

		Point p(origin.x + x_scale, origin.y - axis_length + (current_year - origin_year) * y_scale);

		nodes_coordinates.emplace_back(new Point(p));

		// generate Text using node point and name
		nodes_text.emplace_back(new Graph_lib::Text(p, g.nodes[i].get_name()));
	}

	// generate Arrows by connecting current node point to its ancestors points
	for (size_t i = 0; i < g.get_node_number(); ++i)
	{
		Point src(*nodes_coordinates[i]);
		int color = rand() % 125 + 50;
		for (size_t j = 0; j < g.nodes[i].edge_number(); ++j)
		{
			// find point by name
			std::string node_name = g.nodes[i].ancestor_node_names[j];
			size_t k = g.get_node_index(node_name);
			Point dest(*nodes_coordinates[k]);

			Arrow* a = new Arrow(src, dest, 8);
			a->set_color(color);
			a->set_style(Line_style(Line_style::solid, 2));
			edges.emplace_back(a);
		}
	}
}

#endif